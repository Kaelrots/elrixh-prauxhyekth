<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Haraziel Galaxy Editor v9.16 - Full Spec Restoration</title>
<style>
    :root {
        --bg-color: #020408;
        --panel-bg: rgba(13, 17, 23, 0.95);
        --border-color: #30363d;
        --accent-color: #00ffff;
        --text-main: #e6edf3;
        --text-sub: #8b949e;
        --input-bg: #0d1117;
        --success: #238636;
    }
    body { margin:0; overflow:hidden; background:var(--bg-color); color:var(--text-main); font-family:'Segoe UI', sans-serif; user-select:none; }
    canvas { display:block; width:100vw; height:100vh; cursor:crosshair; }
    
    .panel {
        position: absolute; background: var(--panel-bg); border: 1px solid var(--border-color);
        border-radius: 8px; padding: 10px; display: flex; flex-direction: column; gap: 8px;
        font-size: 12px; z-index: 10; backdrop-filter: blur(4px);
    }

    #toolbar { top: 10px; left: 10px; width: 270px; max-height: 90vh; overflow-y: auto; }
    #inspector { top: 10px; right: 10px; width: 280px; display: none; }
    #hudPanel { bottom: 10px; left: 10px; pointer-events: none; color: #0f0; background: rgba(0,0,0,0.6); padding: 5px; border: 1px solid #005500; font-family: monospace; }
    #navPanel { bottom: 20px; left: 50%; transform: translateX(-50%); width: 300px; display: none; text-align: center; border: 1px solid var(--accent-color); }

    h1 { margin: 0; font-size: 14px; color: var(--accent-color); border-bottom: 1px solid #444; padding-bottom: 5px; }
    .row { display: flex; justify-content: space-between; align-items: center; gap: 5px; }
    
    button { background: #21262d; border: 1px solid #30363d; color: #c9d1d9; padding: 6px; cursor: pointer; width: 100%; border-radius: 4px; }
    button:hover { background: #30363d; border-color: #8b949e; }
    button.primary { background: #1f6feb; color: white; border-color: #1f6feb; }
    button.highlight { border-color: var(--accent-color); color: var(--accent-color); }
    
    input[type="text"], input[type="number"], select { background: var(--input-bg); border: 1px solid #30363d; color: white; padding: 4px; width: 100%; box-sizing: border-box; }
    label.btn { display: block; background: #21262d; border: 1px solid #30363d; padding: 8px; text-align: center; cursor: pointer; border-radius: 4px; color: #c9d1d9; }
    label.btn:hover { background: #30363d; }
    
    #loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); color: var(--accent-color); padding: 20px; border: 1px solid var(--accent-color); border-radius: 8px; display: none; z-index: 100; text-align:center; }
</style>
</head>
<body>

<canvas id="c"></canvas>

<!-- HUD -->
<div id="hudPanel" class="panel">
    <div>POS : <span id="hx">0</span>, <span id="hy">0</span></div>
    <div>ZOOM: <span id="hz">0.1000</span> | NODES: <span id="hc">0</span></div>
</div>

<!-- TOOLBAR -->
<div id="toolbar" class="panel">
    <h1>Haraziel v9.16 <span style="font-size:10px; background:#a371f7; color:white; padding:1px 4px; border-radius:3px;">Full Spec</span></h1>
    
    <!-- SEARCH -->
    <div style="background:rgba(255,255,255,0.05); padding:6px; border-radius:4px;">
        <div class="row">
            <input type="text" id="inpSearch" placeholder="Search ID or Name...">
            <button id="btnSearch" style="width:40px;">Go</button>
        </div>
        <div id="searchResult" style="font-size:11px; margin-top:2px; color:var(--text-sub);"></div>
    </div>

    <!-- FILES -->
    <div style="font-weight:bold; color:var(--text-sub); margin-top:5px;">Data Files</div>
    <label class="btn">üìÇ Nodes (csv) <input type="file" id="fN" accept=".csv"></label>
    <label class="btn">üìÇ Edges (csv) <input type="file" id="fE" accept=".csv"></label>
    
    <!-- TOOLS -->
    <div style="font-weight:bold; color:var(--text-sub); margin-top:5px;">Tools</div>
    <div class="row">
        <button id="btnAudit">üõ°Ô∏è Audit</button>
        <button id="btnSnap" class="highlight">üì∏ Snap</button>
    </div>
    <button id="btnPath" style="margin-top:4px;">üìê Nav Path (Ctrl+Click)</button>
    <button id="btnCam" style="margin-top:4px; color:var(--accent-color);">‚åñ Auto Focus</button>

    <!-- VIEW -->
    <div style="font-weight:bold; color:var(--text-sub); margin-top:5px;">Display</div>
    <div class="row"><input type="checkbox" id="cE" checked> <span>Hyperlanes</span></div>
    <div class="row"><input type="checkbox" id="cR" checked> <span>Rings (KPC)</span></div>
    <div class="row"><input type="checkbox" id="cL" checked> <span>Labels (HUD)</span></div>
    
    <div style="margin-top:auto; padding-top:10px;">
        <button id="btnExp" class="primary">üíæ Save CSV</button>
    </div>
</div>

<!-- INSPECTOR -->
<div id="inspector" class="panel">
    <h1>Inspector</h1>
    <div class="row">
        <input type="text" id="iId" readonly style="background:#222; width:30%;">
        <input type="text" id="iLbl" placeholder="Name">
    </div>
    <div class="row" style="margin-top:5px;">
        <span>Size</span>
        <input type="number" id="iSize" step="0.1" value="1.0">
    </div>
    
    <div style="border-top:1px dashed #444; margin:5px 0;"></div>
    
    <div class="row">
        <span>Type</span>
        <select id="iType">
            <option value="star">Star</option><option value="giant">Giant</option>
            <option value="neutron">Neutron</option><option value="blackhole">Black Hole</option>
        </select>
    </div>
    <div class="row">
        <span>Planet</span>
        <select id="iSubP">
            <option value="">None</option><option value="habitable">Habitable</option>
            <option value="barren">Barren</option><option value="gas">Gas Giant</option>
        </select>
    </div>
    <div class="row">
        <span>Outpost</span>
        <select id="iSubS">
            <option value="">None</option><option value="fortress">Fortress</option>
            <option value="gateway">Gateway</option><option value="wormhole">Wormhole</option>
        </select>
    </div>
    
    <div style="border-top:1px dashed #444; margin:5px 0;"></div>
    
    <div class="row">
        <input type="number" id="iX" step="1">
        <input type="number" id="iY" step="1">
    </div>
    <button id="btnUpd" class="primary" style="margin-top:10px;">Update</button>
</div>

<!-- NAV PANEL -->
<div id="navPanel" class="panel">
    <h1>Navigation</h1>
    <div id="navInfo" style="margin-bottom:5px;">Select Start Point...</div>
    <button id="btnClrPath">Clear Route</button>
</div>

<div id="loader">Processing...</div>

<script>
/**
 * Haraziel Galaxy Editor v9.16 - Full Spec Restoration
 * Restored:
 * 1. Subtype Badges (Planet/Strategic)
 * 2. Size Scaling
 * 3. Extended CSV Parsing & Export
 */

// --- CONFIG ---
const COLORS = {
    // Core
    'star': '#ffffff', 'giant': '#ff4d4d', 'neutron': '#00ffff', 'blackhole': '#bf00ff', 'default': '#00ffff',
    // Subtype P (Planet - Bottom Left)
    'habitable': '#238636', // Green
    'barren': '#8b949e',    // Grey
    'gas': '#d29922',       // Orange
    // Subtype S (Strategic - Bottom Right)
    'fortress': '#da3633',  // Red
    'gateway': '#e3b341',   // Yellow
    'wormhole': '#db6d28'   // Deep Orange
};

// --- STATE ---
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d', { alpha: false });
let nodes = [], edges = [], nodeMap = new Map(), adjList = new Map();
let cam = { x: 0, y: 0, z: 0.1 };
let isDragging = false, lastMouse = { x: 0, y: 0 };
let selectedNode = null;
let navMode = false, navStart = null, navEnd = null, navPath = [];
let reqId = null;

// --- INIT ---
function resize() {
    cvs.width = window.innerWidth;
    cvs.height = window.innerHeight;
    draw();
}
window.addEventListener('resize', resize);

// --- RENDER ---
function draw() {
    // Clear
    ctx.fillStyle = '#020408';
    ctx.fillRect(0, 0, cvs.width, cvs.height);
    
    ctx.save();
    ctx.translate(cvs.width / 2, cvs.height / 2);
    ctx.scale(cam.z, cam.z);
    ctx.translate(-cam.x, -cam.y);
    
    // 1. Rings
    if(document.getElementById('cR').checked) {
        ctx.strokeStyle = '#1a3c40'; ctx.lineWidth = 1/cam.z;
        ctx.textAlign = 'center'; ctx.fillStyle = '#1a3c40';
        const ringStep = 50 * 10; 
        for(let r=ringStep; r<=ringStep*8; r+=ringStep) {
            ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.stroke();
        }
    }

    // 2. Edges
    if (document.getElementById('cE').checked) {
        ctx.strokeStyle = '#2a4c50'; ctx.lineWidth = Math.max(1, 1/cam.z);
        ctx.beginPath();
        for (const e of edges) {
            const u = nodeMap.get(e.s), v = nodeMap.get(e.d);
            if (u && v) { ctx.moveTo(u.x, u.y); ctx.lineTo(v.x, v.y); }
        }
        ctx.stroke();
    }

    // 3. Path
    if (navPath.length > 1) {
        ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 4/cam.z; ctx.beginPath();
        const start = nodeMap.get(navPath[0]); ctx.moveTo(start.x, start.y);
        for(let i=1; i<navPath.length; i++) {
            const n = nodeMap.get(navPath[i]); ctx.lineTo(n.x, n.y);
        }
        ctx.stroke();
    }

    // 4. Nodes
    const vl = cam.x - (cvs.width/2)/cam.z, vr = cam.x + (cvs.width/2)/cam.z;
    const vt = cam.y - (cvs.height/2)/cam.z, vb = cam.y + (cvs.height/2)/cam.z;
    const minSize = 2.0 / cam.z; 
    const showLbl = document.getElementById('cL').checked;
    const BADGE_OFFSET = 0.707; // 45 degrees

    for (const n of nodes) {
        if (n.x < vl || n.x > vr || n.y < vt || n.y > vb) continue;

        let baseR = 20; // Base radius
        if (n.type === 'giant') baseR = 35;
        if (n.type === 'blackhole') baseR = 25;
        if (n.type === 'neutron') baseR = 15;
        
        // Size Factor Apply
        let r = baseR * (n.size || 1.0);
        
        // Visibility Check
        if (r < minSize) r = minSize;

        // Draw Core
        ctx.fillStyle = COLORS[n.type] || COLORS['default'];
        if (cam.z < 0.05) {
            ctx.fillRect(n.x - r/2, n.y - r/2, r, r);
        } else {
            ctx.beginPath(); ctx.arc(n.x, n.y, r, 0, Math.PI*2); ctx.fill();
            if(n.type==='blackhole'){ ctx.strokeStyle='#fff'; ctx.lineWidth=2/cam.z; ctx.stroke(); }
            
            // Draw Badges (Only when zoomed in)
            if (cam.z > 0.15) {
                // Planet Badge (Bottom Left)
                if (n.subtype_p && COLORS[n.subtype_p]) {
                    const bx = n.x - (r * BADGE_OFFSET * 1.3);
                    const by = n.y + (r * BADGE_OFFSET * 1.3);
                    const br = r * 0.5;
                    ctx.beginPath(); ctx.arc(bx, by, br, 0, Math.PI*2);
                    ctx.fillStyle = COLORS[n.subtype_p]; ctx.fill(); 
                }
                // Strategic Badge (Bottom Right)
                if (n.subtype_s && COLORS[n.subtype_s]) {
                    const bx = n.x + (r * BADGE_OFFSET * 1.3);
                    const by = n.y + (r * BADGE_OFFSET * 1.3);
                    const bs = r * 0.45;
                    ctx.beginPath();
                    ctx.moveTo(bx, by-bs); ctx.lineTo(bx+bs, by); ctx.lineTo(bx, by+bs); ctx.lineTo(bx-bs, by);
                    ctx.fillStyle = COLORS[n.subtype_s]; ctx.fill();
                }
            }
        }
        
        // Label/Selection
        const isSel = (n === selectedNode);
        const isNav = (navStart === n || navEnd === n);
        
        if (isSel || isNav || (showLbl && cam.z > 0.3 && n.label)) {
            ctx.fillStyle = isNav ? '#00ff00' : (isSel ? '#fff' : '#aaa');
            const fs = Math.max(12, 14/cam.z);
            ctx.font = `${fs}px Arial`;
            ctx.fillText(n.label || n.id, n.x + r*1.2, n.y);
        }
    }
    
    // Nav Markers
    if (navStart) drawMarker(navStart, '#00ff00');
    if (navEnd) drawMarker(navEnd, '#ff0000');

    // Selection Halo
    if (selectedNode) {
        ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 3/cam.z;
        const r = Math.max(50, 15/cam.z);
        ctx.beginPath(); ctx.arc(selectedNode.x, selectedNode.y, r, 0, Math.PI*2); ctx.stroke();
    }

    ctx.restore();
    
    // HUD
    document.getElementById('hx').innerText = cam.x.toFixed(0);
    document.getElementById('hy').innerText = cam.y.toFixed(0);
    document.getElementById('hz').innerText = cam.z.toFixed(4);
    document.getElementById('hc').innerText = nodes.length;
}

function drawMarker(n, c) {
    const r = Math.max(40, 10/cam.z);
    ctx.strokeStyle = c; ctx.lineWidth = 2/cam.z;
    ctx.beginPath(); ctx.arc(n.x, n.y, r, 0, Math.PI*2); ctx.stroke();
}

// --- DATA ---
document.getElementById('fN').onchange = function(e) {
    const f = e.target.files[0]; if(!f) return;
    const l = document.getElementById('loader');
    l.style.display = 'block'; l.innerText = "Loading Nodes...";
    
    const r = new FileReader();
    r.onload = function(ev) {
        const lines = ev.target.result.split(/\r\n|\n|\r/);
        nodes = []; nodeMap.clear();
        let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
        
        // Header Parsing
        let h = lines[0].toLowerCase().split(',');
        let ix = -1, iy = -1, iid = 0;
        
        // Robust Column Search
        ix = h.indexOf('x'); if(ix<0) ix=h.indexOf('x_px');
        iy = h.indexOf('y'); if(iy<0) iy=h.indexOf('y_px');
        if(h.indexOf('id') > -1) iid = h.indexOf('id');
        
        // Extra features indices
        let ilbl = h.indexOf('label');
        let isz = h.indexOf('size');
        let isp = h.indexOf('subtype_p');
        let iss = h.indexOf('subtype_s');
        let ityp = h.indexOf('type');

        if(ix < 0 || iy < 0) { alert("Error: No X/Y columns found."); l.style.display='none'; return; }

        for(let i=1; i<lines.length; i++) {
            const row = lines[i].split(',');
            if(row.length < 2) continue;
            const x = parseFloat(row[ix]), y = parseFloat(row[iy]);
            if(!isNaN(x) && !isNaN(y)) {
                const n = { 
                    id: row[iid].trim(), 
                    x:x, y:y, 
                    type: (ityp>-1 && row[ityp]) ? row[ityp].trim() : 'star',
                    label: (ilbl>-1 && row[ilbl]) ? row[ilbl].trim() : '',
                    size: (isz>-1 && row[isz]) ? parseFloat(row[isz]) : 1.0,
                    subtype_p: (isp>-1 && row[isp]) ? row[isp].trim() : '',
                    subtype_s: (iss>-1 && row[iss]) ? row[iss].trim() : ''
                };
                if(isNaN(n.size)) n.size = 1.0;
                
                nodes.push(n); nodeMap.set(n.id, n);
                if(x<minX) minX=x; if(x>maxX) maxX=x; if(y<minY) minY=y; if(y>maxY) maxY=y;
            }
        }
        
        cam.x = (minX+maxX)/2; cam.y = (minY+maxY)/2;
        const maxD = Math.max(maxX-minX, maxY-minY);
        cam.z = maxD>0 ? Math.min(cvs.width, cvs.height)/(maxD*1.2) : 1;
        
        if(navMode) buildAdj();
        l.style.display = 'none';
        draw();
        alert(`Loaded ${nodes.length} nodes.\nExtra columns ready.`);
    };
    r.readAsText(f);
};

document.getElementById('fE').onchange = function(e) {
    const f = e.target.files[0]; if(!f) return;
    const r = new FileReader();
    r.onload = function(ev) {
        const lines = ev.target.result.split(/\r\n|\n|\r/);
        edges = [];
        for(let i=1; i<lines.length; i++) {
            const row = lines[i].split(',');
            if(row.length >= 2) {
                const s = row[0].trim(), d = row[1].trim();
                if(s && d && !isNaN(parseFloat(s))) edges.push({s:s, d:d});
            }
        }
        if(navMode) buildAdj();
        draw();
        alert(`Loaded ${edges.length} edges.`);
    };
    r.readAsText(f);
};

// --- INTERACTION ---
cvs.onmousedown = function(e) {
    lastMouse = {x:e.clientX, y:e.clientY};
    const wx = (e.clientX - cvs.width/2)/cam.z + cam.x;
    const wy = (e.clientY - cvs.height/2)/cam.z + cam.y;
    
    // Hit Test (Linear)
    let hit = null, minD = Infinity;
    const tol = 20/cam.z;
    for(const n of nodes) {
        if(Math.abs(n.x - wx) < tol && Math.abs(n.y - wy) < tol) {
            const d = (n.x-wx)**2 + (n.y-wy)**2;
            if(d < minD) { minD=d; hit=n; }
        }
    }

    if(navMode && e.button===0 && e.ctrlKey) {
        if(hit) {
            if(!navStart) { navStart=hit; document.getElementById('navInfo').innerText="End Point?"; }
            else { navEnd=hit; calcPath(); }
        } else { navStart=null; navEnd=null; navPath=[]; }
        draw(); return;
    }

    if(hit && e.button===0) {
        selectedNode = hit;
        document.getElementById('iId').value = hit.id;
        document.getElementById('iLbl').value = hit.label;
        document.getElementById('iSize').value = hit.size;
        document.getElementById('iType').value = hit.type;
        document.getElementById('iSubP').value = hit.subtype_p;
        document.getElementById('iSubS').value = hit.subtype_s;
        document.getElementById('iX').value = hit.x;
        document.getElementById('iY').value = hit.y;
        document.getElementById('inspector').style.display = 'flex';
        draw();
    } else { isDragging = true; }
};

cvs.onmousemove = function(e) {
    if(isDragging) {
        cam.x -= (e.clientX - lastMouse.x) / cam.z;
        cam.y -= (e.clientY - lastMouse.y) / cam.z;
        lastMouse = {x:e.clientX, y:e.clientY};
        requestAnimationFrame(draw);
    }
};
cvs.onmouseup = function() { isDragging = false; };
cvs.onwheel = function(e) {
    e.preventDefault();
    cam.z *= (e.deltaY > 0 ? 0.95 : 1.05); // Smooth Zoom
    if(cam.z < 0.001) cam.z=0.001; if(cam.z > 50) cam.z=50;
    requestAnimationFrame(draw);
};

// --- TOOLS ---
document.getElementById('btnCam').onclick = function() {
    if(nodes.length) {
        let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
        for(let n of nodes){ if(n.x<minX)minX=n.x; if(n.x>maxX)maxX=n.x; if(n.y<minY)minY=n.y; if(n.y>maxY)maxY=n.y; }
        cam.x = (minX+maxX)/2; cam.y = (minY+maxY)/2;
        const maxD = Math.max(maxX-minX, maxY-minY);
        cam.z = Math.min(cvs.width, cvs.height)/(maxD*1.2);
    } else { cam = {x:0, y:0, z:0.1}; }
    draw();
};

document.getElementById('btnSearch').onclick = function() {
    const q = document.getElementById('inpSearch').value.toLowerCase();
    const t = nodes.find(n => n.id === q || (n.label && n.label.toLowerCase().includes(q)));
    if(t) {
        selectedNode = t;
        cam.x = t.x; cam.y = t.y; cam.z = Math.max(cam.z, 1.0);
        document.getElementById('searchResult').innerText = `Found: ${t.id}`;
        draw();
    } else { document.getElementById('searchResult').innerText = "Not found."; }
};

document.getElementById('btnSnap').onclick = function() {
    const s = 2; const c = document.createElement('canvas'); c.width=cvs.width*s; c.height=cvs.height*s;
    const cx = c.getContext('2d');
    cx.fillStyle = '#020408'; cx.fillRect(0,0,c.width,c.height);
    cx.save(); cx.translate(c.width/2, c.height/2); cx.scale(cam.z*s, cam.z*s); cx.translate(-cam.x, -cam.y);
    // Draw Nodes Only logic for snapshot (simplified)
    for(const n of nodes) {
        let r = 20 * n.size; cx.beginPath(); cx.arc(n.x, n.y, r, 0, Math.PI*2);
        cx.fillStyle = COLORS[n.type] || '#0ff'; cx.fill();
    }
    cx.restore();
    c.toBlob(b => { const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = 'Map.png'; a.click(); });
};

document.getElementById('btnPath').onclick = function() {
    navMode = !navMode;
    document.getElementById('navPanel').style.display = navMode ? 'block' : 'none';
    this.style.color = navMode ? '#00ff00' : 'white';
    if(navMode) buildAdj();
};

function buildAdj() {
    adjList.clear();
    nodes.forEach(n => adjList.set(n.id, []));
    edges.forEach(e => {
        if(adjList.has(e.s)) adjList.get(e.s).push(e.d);
        if(adjList.has(e.d)) adjList.get(e.d).push(e.s);
    });
}

function calcPath() {
    if(!navStart || !navEnd) return;
    const q = [navStart.id], visited = new Set([navStart.id]), parent = new Map();
    let found = false;
    while(q.length) {
        const curr = q.shift();
        if(curr === navEnd.id) { found = true; break; }
        for(const n of (adjList.get(curr)||[])) {
            if(!visited.has(n)) { visited.add(n); parent.set(n, curr); q.push(n); }
        }
    }
    if(found) {
        navPath = [navEnd.id]; let curr = navEnd.id;
        while(curr !== navStart.id) { curr = parent.get(curr); navPath.unshift(curr); }
        document.getElementById('navInfo').innerText = `Jumps: ${navPath.length-1}`;
    } else { document.getElementById('navInfo').innerText = "No Route."; }
}
document.getElementById('btnClrPath').onclick = function(){ navStart=null; navEnd=null; navPath=[]; draw(); };

document.getElementById('btnUpd').onclick = function() {
    if(!selectedNode) return;
    selectedNode.label = document.getElementById('iLbl').value;
    selectedNode.size = parseFloat(document.getElementById('iSize').value);
    selectedNode.type = document.getElementById('iType').value;
    selectedNode.subtype_p = document.getElementById('iSubP').value;
    selectedNode.subtype_s = document.getElementById('iSubS').value;
    selectedNode.x = parseFloat(document.getElementById('iX').value);
    selectedNode.y = parseFloat(document.getElementById('iY').value);
    draw();
};

document.getElementById('btnExp').onclick = function() {
    if(!nodes.length) return;
    const h = ['id','x','y','type','label','size','subtype_p','subtype_s'];
    let csv = h.join(',')+'\n';
    nodes.forEach(n => {
        csv += h.map(k => n[k]===undefined?'':n[k]).join(',')+'\n';
    });
    const b=new Blob([csv],{type:'text/csv'}); const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download='nodes_updated.csv'; a.click();
};

document.getElementById('btnAudit').onclick = function() {
    if(!nodes.length) return;
    const orphans = nodes.filter(n => !edges.some(e=>e.s===n.id || e.d===n.id)).length;
    alert(`Audit:\nOrphans: ${orphans}\nDuplicates: Check Console`);
};

// Toggles
document.getElementById('cE').onchange = draw;
document.getElementById('cR').onchange = draw;
document.getElementById('cL').onchange = draw;

resize();
</script>
</body>
</html>
# -*- coding: utf-8 -*-
"""Data Refinery v3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rgzg2EzrKed0aRj8X9mCbH1IpBgHdjNo
"""

import csv
import os

# === 설정 ===
INPUT_NODES = 'nodes.csv'
INPUT_EDGES = 'haraziel_50kpc_37219_hyperlanes_edges.csv'

OUTPUT_NODES = 'nodes_centered.csv'
OUTPUT_EDGES = 'edges_clean.csv'

# 좌표 이동 (True면 은하 중심을 0,0으로 맞춤)
AUTO_CENTER = True

def refine_data():
    if not os.path.exists(INPUT_NODES):
        print(f"[오류] '{INPUT_NODES}' 파일이 없습니다.")
        return

    print(f"[1/3] 노드 데이터 로드 및 분석 중...")

    raw_nodes = []
    min_x, max_x = float('inf'), float('-inf')
    min_y, max_y = float('inf'), float('-inf')

    # 1. 데이터 읽기 및 범위 계산
    with open(INPUT_NODES, 'r', encoding='utf-8-sig', errors='replace') as f:
        lines = f.readlines()
        if len(lines) < 2: return

        # 헤더 파싱
        headers = [h.strip().lower() for h in lines[0].split(',')]

        # 컬럼 인덱스 찾기 (유연하게)
        try:
            ix = headers.index('x_px') if 'x_px' in headers else headers.index('x')
            iy = headers.index('y_px') if 'y_px' in headers else headers.index('y')
            iid = headers.index('id') if 'id' in headers else 0

            # 부가 정보 인덱스 (있으면)
            itype = headers.index('type') if 'type' in headers else -1
            ilabel = headers.index('label') if 'label' in headers else -1
            isize = headers.index('size') if 'size' in headers else -1
            ir = headers.index('r_kpc') if 'r_kpc' in headers else -1

        except ValueError:
            print("[오류] x_px, y_px 컬럼을 찾을 수 없습니다.")
            return

        for line in lines[1:]:
            parts = line.split(',')
            if len(parts) <= max(ix, iy): continue

            try:
                x = float(parts[ix])
                y = float(parts[iy])

                # 범위 갱신
                if x < min_x: min_x = x
                if x > max_x: max_x = x
                if y < min_y: min_y = y
                if y > max_y: max_y = y

                # 데이터 임시 저장
                node = {
                    'id': parts[iid].strip(),
                    'x': x,
                    'y': y,
                    'type': parts[itype].strip() if itype >= 0 and len(parts) > itype else 'star',
                    'label': parts[ilabel].strip() if ilabel >= 0 and len(parts) > ilabel else '',
                    'size': float(parts[isize]) if isize >= 0 and len(parts) > isize and parts[isize].strip() else 1.0,
                    'r_kpc': float(parts[ir]) if ir >= 0 and len(parts) > ir and parts[ir].strip() else 0.0,
                    'subtype_p': '', # 추후 에디터에서 지정
                    'subtype_s': ''
                }
                raw_nodes.append(node)

            except ValueError:
                continue

    # 2. 중심점 계산 (Auto-Center)
    center_x, center_y = 0, 0
    if AUTO_CENTER:
        center_x = (min_x + max_x) / 2
        center_y = (min_y + max_y) / 2
        print(f"   └ 감지된 중심점: ({center_x:.1f}, {center_y:.1f}) -> (0, 0)으로 이동합니다.")

    # 3. 노드 파일 쓰기 (좌표 보정)
    print(f"[2/3] 정제된 노드 저장 중: {OUTPUT_NODES}")
    with open(OUTPUT_NODES, 'w', encoding='utf-8', newline='') as f_out:
        fieldnames = ['id', 'x', 'y', 'type', 'label', 'size', 'subtype_p', 'subtype_s', 'r_kpc']
        writer = csv.DictWriter(f_out, fieldnames=fieldnames)
        writer.writeheader()

        for n in raw_nodes:
            # 좌표 이동 적용
            n['x'] = round(n['x'] - center_x, 3)
            n['y'] = round(n['y'] - center_y, 3)

            # 타입 데이터 정제 (빈 값이면 star)
            if not n['type']: n['type'] = 'star'

            writer.writerow(n)

    # 4. 엣지 파일 단순 복사 (헤더 표준화)
    print(f"[3/3] 엣지 데이터 표준화: {OUTPUT_EDGES}")
    if os.path.exists(INPUT_EDGES):
        with open(INPUT_EDGES, 'r', encoding='utf-8-sig', errors='replace') as f_in, \
             open(OUTPUT_EDGES, 'w', encoding='utf-8', newline='') as f_out:

            lines = f_in.readlines()
            writer = csv.writer(f_out)
            writer.writerow(['source', 'target'])

            count = 0
            for line in lines:
                parts = [p.strip() for p in line.split(',')]
                if len(parts) >= 2:
                    # 숫자로 된 ID만 추출 (헤더 건너뛰기용)
                    s, d = parts[0], parts[1]
                    # 첫 글자가 숫자거나 '-'인 경우만 (ID가 숫자인 경우)
                    if s and (s[0].isdigit() or s[0] == '-'):
                        writer.writerow([s, d])
                        count += 1
            print(f"   └ {count}개 연결 저장 완료.")
    else:
        print("   └ 엣지 파일이 없어 건너뜁니다.")

    print("\n[완료] 모든 작업이 끝났습니다.")
    print(f"1. 생성된 '{OUTPUT_NODES}'를 에디터에 넣으세요.")
    print(f"2. 생성된 '{OUTPUT_EDGES}'를 에디터에 넣으세요.")

if __name__ == "__main__":
    refine_data()
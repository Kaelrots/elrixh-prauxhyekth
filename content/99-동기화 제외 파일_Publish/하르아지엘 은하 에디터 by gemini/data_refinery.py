# -*- coding: utf-8 -*-
"""Data Refinery

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PDc_Ck-XqTgtdsyCsad2u0kVlZob8rOs
"""

import csv
import os

# --- 설정 ---
INPUT_NODES = 'nodes.csv'
INPUT_EDGES = 'haraziel_50kpc_37219_hyperlanes_edges.csv'
OUTPUT_NODES = 'nodes_clean.csv'
OUTPUT_EDGES = 'edges_clean.csv'

def clean_nodes():
    if not os.path.exists(INPUT_NODES):
        print(f"[오류] '{INPUT_NODES}' 파일이 없습니다.")
        return

    print(f"[진행] {INPUT_NODES} 정련 중...")

    with open(INPUT_NODES, 'r', encoding='utf-8-sig', errors='replace') as f_in, \
         open(OUTPUT_NODES, 'w', encoding='utf-8', newline='') as f_out:

        reader = csv.DictReader(f_in)
        # 헤더 공백 제거 및 소문자 변환
        reader.fieldnames = [h.strip().lower() for h in reader.fieldnames]

        # 에디터 최적화 헤더
        fieldnames = ['id', 'x_px', 'y_px', 'type', 'label', 'r_kpc', 'size']
        writer = csv.DictWriter(f_out, fieldnames=fieldnames)
        writer.writeheader()

        count = 0
        for row in reader:
            try:
                # 필수 좌표가 없으면 스킵
                if not row.get('x_px') or not row.get('y_px'):
                    continue

                # 데이터 매핑
                new_row = {
                    'id': row.get('id', str(count)),
                    'x_px': float(row['x_px']),
                    'y_px': float(row['y_px']),
                    'type': 'star',  # 기본값
                    'label': row.get('label', ''),
                    'r_kpc': row.get('r_kpc', 0),
                    'size': 1.0
                }

                # 타입 추론 (특수 컬럼이 있다면)
                # 예: blackhole 등 로직 추가 가능

                writer.writerow(new_row)
                count += 1
            except ValueError:
                continue

    print(f"[완료] {count}개 성계가 '{OUTPUT_NODES}'로 변환되었습니다.")

def clean_edges():
    if not os.path.exists(INPUT_EDGES):
        return

    print(f"[진행] {INPUT_EDGES} 정련 중...")
    try:
        with open(INPUT_EDGES, 'r', encoding='utf-8-sig', errors='replace') as f_in, \
             open(OUTPUT_EDGES, 'w', encoding='utf-8', newline='') as f_out:

            # 엣지 파일은 헤더가 없을 수도 있으니 단순 처리
            lines = f_in.readlines()
            writer = csv.writer(f_out)
            writer.writerow(['src', 'dst']) # 헤더 강제 주입

            count = 0
            for line in lines:
                parts = line.strip().split(',')
                if len(parts) >= 2:
                    # 숫자가 아닌 헤더 라인은 스킵
                    if not parts[0].isdigit(): continue
                    writer.writerow([parts[0].strip(), parts[1].strip()])
                    count += 1

        print(f"[완료] {count}개 항로가 '{OUTPUT_EDGES}'로 변환되었습니다.")
    except Exception as e:
        print(f"[경고] 엣지 변환 중 오류: {e}")

if __name__ == "__main__":
    clean_nodes()
    clean_edges()
    print("\n[지침] 생성된 'nodes_clean.csv'와 'edges_clean.csv'를 에디터에 넣으세요.")